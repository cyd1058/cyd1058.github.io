<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>《Java 编程思想》读书笔记 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="初始化与清理 
内部类
容器深入研究
并发  

一、初始化与清理初始化
初始化其实就是为变量分配内存空间，并确定其初始值的过程。1.1 何时初始化大概有以下几种情况:I. 首次创建某个类的实例:new, 反射,克隆,反序列化; 
II. 静态方法或静态字段调用;
III. 初始化其子类;
IV. JVM 启动含有 main() 的启动类。
1.2 初始化顺序
想了解Java中初始化的各种情况，首">
<meta property="og:type" content="article">
<meta property="og:title" content="《Java 编程思想》读书笔记">
<meta property="og:url" content="http://yoursite.com/2015/12/14/Java-Thinking-notes/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="初始化与清理 
内部类
容器深入研究
并发  

一、初始化与清理初始化
初始化其实就是为变量分配内存空间，并确定其初始值的过程。1.1 何时初始化大概有以下几种情况:I. 首次创建某个类的实例:new, 反射,克隆,反序列化; 
II. 静态方法或静态字段调用;
III. 初始化其子类;
IV. JVM 启动含有 main() 的启动类。
1.2 初始化顺序
想了解Java中初始化的各种情况，首">
<meta property="og:image" content="http://yoursite.com/./memory.jpg">
<meta property="og:image" content="http://yoursite.com/./collections.png">
<meta property="og:updated_time" content="2015-12-14T11:52:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《Java 编程思想》读书笔记">
<meta name="twitter:description" content="初始化与清理 
内部类
容器深入研究
并发  

一、初始化与清理初始化
初始化其实就是为变量分配内存空间，并确定其初始值的过程。1.1 何时初始化大概有以下几种情况:I. 首次创建某个类的实例:new, 反射,克隆,反序列化; 
II. 静态方法或静态字段调用;
III. 初始化其子类;
IV. JVM 启动含有 main() 的启动类。
1.2 初始化顺序
想了解Java中初始化的各种情况，首">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Java-Thinking-notes" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/14/Java-Thinking-notes/" class="article-date">
  <time datetime="2015-12-14T11:52:38.000Z" itemprop="datePublished">2015-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      《Java 编程思想》读书笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>初始化与清理 </li>
<li>内部类</li>
<li>容器深入研究</li>
<li>并发  </li>
</ul>
<h1 id="u4E00_u3001_u521D_u59CB_u5316_u4E0E_u6E05_u7406"><a href="#u4E00_u3001_u521D_u59CB_u5316_u4E0E_u6E05_u7406" class="headerlink" title="一、初始化与清理"></a>一、初始化与清理</h1><h2 id="u521D_u59CB_u5316"><a href="#u521D_u59CB_u5316" class="headerlink" title="初始化"></a>初始化</h2><ul>
<li>初始化其实就是为变量分配内存空间，并确定其初始值的过程。<h3 id="1-1__u4F55_u65F6_u521D_u59CB_u5316"><a href="#1-1__u4F55_u65F6_u521D_u59CB_u5316" class="headerlink" title="1.1 何时初始化"></a>1.1 何时初始化</h3>大概有以下几种情况:<pre><code>I. 首次创建某个类的实例:new, 反射,克隆,反序列化; 
II. 静态方法或静态字段调用;
III. 初始化其子类;
IV. JVM 启动含有 main() 的启动类。
</code></pre><h3 id="1-2__u521D_u59CB_u5316_u987A_u5E8F"><a href="#1-2__u521D_u59CB_u5316_u987A_u5E8F" class="headerlink" title="1.2 初始化顺序"></a>1.2 初始化顺序</h3></li>
<li>想了解Java中初始化的各种情况，首先要了解Java中变量的类型。Java中的变量类型主要分成以下几种：<h5 id="1-2-1__u5C40_u90E8_u53D8_u91CF"><a href="#1-2-1__u5C40_u90E8_u53D8_u91CF" class="headerlink" title="1.2.1 局部变量"></a>1.2.1 局部变量</h5></li>
<li><p>内存空间被分配在堆栈上；一般是在方法中定义的变量；其初始化操作是必须的，否则编译器会报错，初始化操作有两种方式：一种是在定义的时候初始化其值，另一种是定义和初始化值分开，如下面所示：</p>
<pre><code>int a = 6;
//或者
int a;
a = 6;
</code></pre><h5 id="1-2-2__u9759_u6001_u6210_u5458_u53D8_u91CF_uFF08static_u53D8_u91CF_u6216_u8005_u7C7B_u53D8_u91CF_uFF09"><a href="#1-2-2__u9759_u6001_u6210_u5458_u53D8_u91CF_uFF08static_u53D8_u91CF_u6216_u8005_u7C7B_u53D8_u91CF_uFF09" class="headerlink" title="1.2.2 静态成员变量（static变量或者类变量）"></a>1.2.2 静态成员变量（static变量或者类变量）</h5></li>
<li>内存空间被分配在堆上，而且只占一份存储区域，即多个实例共享一个static变量；它的初始化操作是可选的，如果不人为对其进行初始化，它将会被自动初始化，人为初始化操作是在定义时对其进行赋值；其初始化过程只在类第一次实例化或者第一次调用静态方法的时候完成的。<h5 id="1-2-3__u975E_u9759_u6001_u6210_u5458_u53D8_u91CF_uFF08_u666E_u901A_u6210_u5458_u53D8_u91CF_uFF09"><a href="#1-2-3__u975E_u9759_u6001_u6210_u5458_u53D8_u91CF_uFF08_u666E_u901A_u6210_u5458_u53D8_u91CF_uFF09" class="headerlink" title="1.2.3 非静态成员变量（普通成员变量）"></a>1.2.3 非静态成员变量（普通成员变量）</h5></li>
<li>内存空间被分配在堆上；初始化操作也是可选的，如果不人为初始化则会被自动初始化，初始化操作是在定义时对其赋值。<h5 id="1-2-4__u5F15_u7528_u53D8_u91CF_uFF08_u5BF9_u8C61_u53D8_u91CF_uFF09"><a href="#1-2-4__u5F15_u7528_u53D8_u91CF_uFF08_u5BF9_u8C61_u53D8_u91CF_uFF09" class="headerlink" title="1.2.4 引用变量（对象变量）"></a>1.2.4 引用变量（对象变量）</h5></li>
<li><p>即类的实例；是通过new的方式在堆上分配内存空间的；在被new完后，类的构造器被调用，从而完成初始化过程；如果在定义类时没有定义构造器，则默认构造器会在初始化过程中被调用，构造器还可以被重载，通过参数列表的不同来区分不同的构造器。</p>
<p>   <strong>初始化顺序是：</strong></p>
<pre><code>1、父类静态成员变量和静态代码块，按在代码中出现的先后顺序
2、子类静态成员变量和静态代码块块，按在代码中出现的先后顺序
3、父类非静态成员变量，按在代码中出现的先后顺序
4、父类构造器
5、子类非静态成员变量，按在代码中出现的先后顺序
6、子类构造器
</code></pre><h3 id="1-3__u7C7B_u5DE5_u4F5C_u7EC6_u8282"><a href="#1-3__u7C7B_u5DE5_u4F5C_u7EC6_u8282" class="headerlink" title="1.3 类工作细节"></a>1.3 类工作细节</h3></li>
<li>要使用一个类为自己工作,要经过以下过程:<pre><code>I. 加载。 把类的.class 加载到内存。把.class 文件放到运行时的数据区的方法区 ,然后在堆建立一个 java.lang.Class 对象。
II. 连接。1⃣️主要验证内存中的字节码是否符合 JVM 规范,这是出于安全性考虑。比如防止一个非法类工作。实际上,加载和连接可以是交替进行的。2⃣️为类的静态变量分配内存,初始化为默认值。但常量会直接是我们设定的值。3⃣️把常量池的符号引用转换为直接引用 。它的工作是把类名,接口名,字段名,方法名转换成具体的内存地址。
III. 初始化。 把类的静态变量正确初始。
</code></pre><h3 id="1-4__u6D89_u53CA_u5185_u90E8_u7C7B_u7684_u521D_u59CB_u5316"><a href="#1-4__u6D89_u53CA_u5185_u90E8_u7C7B_u7684_u521D_u59CB_u5316" class="headerlink" title="1.4 涉及内部类的初始化"></a>1.4 涉及内部类的初始化</h3></li>
<li>非静态内部类就相当于外围类的一个数据成员 ,所以在初始化时必须先创建一个外围类对象。静态内部类可以直接使用外围类调用内部类的构造器 。</li>
</ul>
<ul>
<li><strong>补充</strong><br><img src="./memory.jpg" width="100%" height="100%"><br>上面就是我们常说的JVM的内存了。它主要分为五个部分：<pre><code>- 1、堆：存放所有new出来的对象
- 2、栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中（字符串常量对象存放在常量池中。）
- 3、方法区：被加载的class的信息存储在方法区。当虚拟机装载某个类型时，它使用类装载器定位相应的class文件，然后读入这个class文件内容并把它传输到虚拟机中。
- 4、程序计数器：每一个线程都有它自己的PC寄存器，也是该线程启动时创建的。PC寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。
- 5、本地方法栈：保存native方法进入区域的地址
</code></pre></li>
</ul>
<h2 id="u6E05_u7406"><a href="#u6E05_u7406" class="headerlink" title="清理"></a>清理</h2><ul>
<li><p>Java中提供了垃圾回收器用于自动回收在程序中通过new创建的内存空间，垃圾回收(Garbage Collection)的目的是为了释放内存,这也是它的唯一目的。它的工作是“找到”没用的对象,等内存不够用时,释放其内存。如果要释放其他资源(非 new 创建的),可能会用到 finalize()函数,JVM 会在内存回收前调用该方法 。</p>
<h3 id="1-5__u4F55_u65F6_u56DE_u6536"><a href="#1-5__u4F55_u65F6_u56DE_u6536" class="headerlink" title="1.5 何时回收"></a>1.5 何时回收</h3><h4 id="1-5-1__u5F15_u7528"><a href="#1-5-1__u5F15_u7528" class="headerlink" title="1.5.1 引用"></a>1.5.1 引用</h4><p>回收的条件可以笼统的说成对象 “不可达”,即没有指向它的引用 。但不能说没有引用的”对象“是无用的。实际上,引用分为很多种:JDK1.2 后把引用分为强引用,软引用,弱引用,虚引用。</p>
<pre><code>1、强引用是我们最常用的那种,JVM 不会回收它,宁愿抛出 Out of Memory 的异常;
2、软引用，弱引用都是“可有可无的”,软引用只有内存不足时, gc 才会将它视为回收对象；
3、弱引用无论当前内存是否满足,gc 都会去回收它;
4、虚引用随时有被回收的可能。
</code></pre><p>但满足回收条件也不一定会被回收,部分原因是 GC 是个低优先级的线程。因此,我们并不能知道垃圾回收何时发生。</p>
<pre><code>String a = &quot;Hello&quot;;
// 创建引用队列, &lt;String&gt;为泛型标记,表明队列中存放String对象的引用 
ReferenceQueue&lt;String&gt; rq = new ReferenceQueue&lt;String&gt;();
// 创建一个弱引用,它引用&quot;hello&quot;对象,并且与rq引用队列关联 
WeakReference&lt;String&gt; wf = new WeakReference&lt;String&gt;(a,rq); a=null;
System.out.println(wf.get());
前三行使”Hello&quot;对象和强引用,和弱引用同时关联。当把强引用置 null 后,仍能访问。 我们可以在必要时调用 System.gc()方法,建议 JVM 进行垃圾回收,但这不是强制的。
</code></pre><h4 id="1-5-2_finally__u548C_u6E05_u7406"><a href="#1-5-2_finally__u548C_u6E05_u7406" class="headerlink" title="1.5.2 finally 和清理"></a>1.5.2 finally 和清理</h4><p>在异常处理的 finally 关键字,有个特性”总是会执行“,这符合清理工作的需求。 现在有个问题,如果 finally 块的工作是清理一个已创建的对象,但如果对象可能在构造器里就构造失败了,那么 finally 块就无法正常执行。比如一个文件流尚未打开,关闭就会出错;一个数据库已经是连接的,再连接就会出错。对于每个特列,处理的方法可以在 finally 语句加入判断，但更通用处理方法是,把原来的 finally 块嵌入到 try 语句里。具体规则是,创建要清理的对象后,马上进入 try,,,finally。</p>
<h4 id="1-5-3__u5783_u573E_u56DE_u6536_u5E38_u89C1_u51E0_u79CD_u65B9_u5F0F"><a href="#1-5-3__u5783_u573E_u56DE_u6536_u5E38_u89C1_u51E0_u79CD_u65B9_u5F0F" class="headerlink" title="1.5.3 垃圾回收常见几种方式"></a>1.5.3 垃圾回收常见几种方式</h4><pre><code>有几种垃圾收集的基本策略：引用计数、标记-清除、标记-整理 (mark-compact) 和复制。
</code></pre><h5 id="u5F15_u7528_u8BA1_u6570"><a href="#u5F15_u7528_u8BA1_u6570" class="headerlink" title="引用计数"></a>引用计数</h5><pre><code>最直观的垃圾收集策略是引用计数，适用于增量收集。
</code></pre><p>每一个对象都有一个关联的引用计数 ―― 对该对象的活跃引用的数量。如果对象的引用计数是零，那么它就是垃圾（用户程序不可到达它），并可以回收。每次修改指针引用时（比如通过赋值语句），或者当引用超出范围时，编译器必须生成代码以更新引用的对象的引用计数。如果对象的引用计数变为零，那么运行时就可以立即收回这个块（并且减少被回收的块所引用的所有块的引用计数），或者将它放到迟延收集队列中。</p>
<h5 id="u6807_u8BB0-_u6E05_u9664"><a href="#u6807_u8BB0-_u6E05_u9664" class="headerlink" title="标记-清除"></a>标记-清除</h5><pre><code>可以容易地回收循环的结构，但是它也有不足 ―― 收集暂停可能会很长
</code></pre><p>停止所有工作，收集器从根开始访问每一个活跃的节点，标记它所访问的每一个节点。走过所有引用后，收集就完成了，然后就对堆进行清除（即对堆中的每一个对象进行检查），所有没有标记的对象都作为垃圾回收并返回空闲列表。</p>
<h5 id="u590D_u5236"><a href="#u590D_u5236" class="headerlink" title="复制"></a>复制</h5><pre><code>优点是只访问活跃的对象
</code></pre><p>复制收集器中，堆被分成两个大小相等的半空间，其中一个包含活跃的数据，另一个未使用。当活跃的空间占满以后，程序就会停止，活跃的对象被从活跃的空间复制到不活跃的空间中。空间的角色就会转换，原来不活跃的空间成为了新的活跃空间。</p>
<h5 id="u6807_u8BB0-_u6574_u7406"><a href="#u6807_u8BB0-_u6574_u7406" class="headerlink" title="标记-整理"></a>标记-整理</h5><pre><code>算法结合了标记-清除和复制，优点：避免过多消耗内存
</code></pre><p>与标记-清除类似，标记-整理是两阶段过程，在标记阶段访问并标记每个活跃对象。然后，复制标记的对象，使所有活跃对象被整理到堆的底部。</p>
</li>
</ul>
<p>JDK 使用了哪种方式进行垃圾收集？在某种意义上，使用了所有的方式。早期的 JDK 使用了单线程的标记-清除或者标记-清除-整理收集器。1.2 及以后的 JDK 使用了混合的方式，称为分代收集，分代收集证明是非常高效的。</p>
<h1 id="u4E8C_u3001_u5185_u90E8_u7C7B"><a href="#u4E8C_u3001_u5185_u90E8_u7C7B" class="headerlink" title="二、内部类"></a>二、内部类</h1><ul>
<li>将相关的类组织在一起，从而降低了命名空间的混乱。</li>
<li><p>一个内部类可以定义在另一个类里，可以定义在函数里，甚至可以作为一个表达式的一部分。</p>
<pre><code>Java中的内部类共分为四种：
I.   静态内部类
II.  成员内部类
III. 局部内部类
IV.  匿名内部类
</code></pre></li>
</ul>
<h2 id="2-1__u9759_u6001_u5185_u90E8_u7C7B"><a href="#2-1__u9759_u6001_u5185_u90E8_u7C7B" class="headerlink" title="2.1 静态内部类"></a>2.1 静态内部类</h2><ul>
<li>最简单的内部类形式。</li>
<li>类定义时加上<strong>static</strong>关键字。</li>
<li>不能和外部类有相同的名字。</li>
<li>被编译成一个完全独立的.class文件，名称为OuterClass$InnerClass.class的形式。</li>
<li><strong>只可以访问外部类的静态成员和静态方法</strong>，包括了私有的静态成员和方法。</li>
<li><p>生成静态内部类对象的方式为：</p>
<pre><code>OuterClass.InnerClass inner = new OuterClass.InnerClass();
</code></pre></li>
</ul>
<p>　　静态内部类使用代码：</p>
<pre><code>package com.learnjava.innerclass;

class StaticInner
{
    private static int a = 4;

    // 静态内部类
    public static class Inner
    {
        public void test()
        {
            // 静态内部类可以访问外部类的静态成员
            // 并且它只能访问静态的
            System.out.println(a);
        }

    }
}

public class StaticInnerClassTest
{

    public static void main(String[] args)
    {
        StaticInner.Inner inner = new StaticInner.Inner();
        inner.test();
    }
}
</code></pre><h2 id="2-2__u6210_u5458_u5185_u90E8_u7C7B"><a href="#2-2__u6210_u5458_u5185_u90E8_u7C7B" class="headerlink" title="2.2 成员内部类"></a>2.2 成员内部类</h2><ul>
<li>成员内部类也是定义在另一个类中，但是定义时不用static修饰。</li>
<li>成员内部类和静态内部类可以类比为非静态的成员变量和静态的成员变量。</li>
<li>成员内部类就像一个实例变量。</li>
<li><strong>它可以访问它的外部类的所有成员变量和方法，不管是静态的还是非静态的都可以</strong>。</li>
<li><p>在外部类里面创建成员内部类的实例：</p>
<pre><code>this.new Innerclass();
</code></pre></li>
<li><p>在外部类之外创建内部类的实例：</p>
<pre><code>(new Outerclass()).new Innerclass();
</code></pre></li>
<li><p>在内部类里访问外部类的成员：</p>
<pre><code>Outerclass.this.member
</code></pre></li>
</ul>
<p>　　详情见代码例子：</p>
<pre><code>package com.learnjava.innerclass;

class MemberInner
{
    private int d = 1;
    private int a = 2;

    // 定义一个成员内部类
    public class Inner2
    {
        private int a = 8;

        public void doSomething()
        {
            // 直接访问外部类对象
            System.out.println(d);
            System.out.println(a);// 直接访问a，则访问的是内部类里的a

            // 如何访问到外部类里的a呢？
            System.out.println(MemberInner.this.a);
        }

    }

}

public class MemberInnerClassTest
{

    public static void main(String[] args)
    {

        // 创建成员内部类的对象
        // 需要先创建外部类的实例
        MemberInner.Inner2 inner = new MemberInner().new Inner2();

        inner.doSomething();
    }
}
</code></pre><h2 id="2-3__u5C40_u90E8_u5185_u90E8_u7C7B"><a href="#2-3__u5C40_u90E8_u5185_u90E8_u7C7B" class="headerlink" title="2.3 局部内部类"></a>2.3 局部内部类</h2><ul>
<li>局部内部类定义在方法中，比方法的范围还小。是内部类中最少用到的一种类型。</li>
<li>像局部变量一样，不能被public, protected, private和static修饰。</li>
<li>只能访问方法中定义的<strong>final</strong>类型的局部变量。</li>
<li>局部内部类在方法中定义，所以只能在方法中使用，即只能在方法当中生成局部内部类的实例并且调用其方法。</li>
</ul>
<pre><code>package com.learnjava.innerclass;

class LocalInner
{
  int a = 1;

  public void doSomething()
  {
      int b = 2;
      final int c = 3;
      // 定义一个局部内部类
      class Inner3
      {
          public void test()
          {
              System.out.println(&quot;Hello World&quot;);
              System.out.println(a);

              // 不可以访问非final的局部变量
              // error: Cannot refer to a non-final variable b inside an inner
              // class defined in a different method
              // System.out.println(b);

              // 可以访问final变量
              System.out.println(c);
          }
      }

      // 创建局部内部类的实例并调用方法
      new Inner3().test();
  }
}

public class LocalInnerClassTest
{
    public static void main(String[] args)
    {
        // 创建外部类对象
        LocalInner inner = new LocalInner();
        // 调用外部类的方法
        inner.doSomething();
    }

}
</code></pre><h2 id="2-4__u533F_u540D_u5185_u90E8_u7C7B"><a href="#2-4__u533F_u540D_u5185_u90E8_u7C7B" class="headerlink" title="2.4 匿名内部类"></a>2.4 匿名内部类</h2><ul>
<li>匿名内部类就是没有名字的局部内部类，不使用关键字class, extends, implements, 没有构造方法。</li>
<li>匿名内部类隐式地<strong>继承了一个父类</strong>或者<strong>实现了一个接口</strong>。</li>
<li>匿名内部类使用得比较多，通常是作为一个方法参数。</li>
</ul>
<pre><code>package com.learnjava.innerclass;

import java.util.Date;

public class AnonymouseInnerClass
{

    @SuppressWarnings(&quot;deprecation&quot;)
    public String getDate(Date date)
    {
        return date.toLocaleString();

    }

    public static void main(String[] args)
    {
        AnonymouseInnerClass test = new AnonymouseInnerClass();

        // 打印日期：
        String str = test.getDate(new Date());
        System.out.println(str);
        System.out.println(&quot;----------------&quot;);

        // 使用匿名内部类
        String str2 = test.getDate(new Date()
        {
        });// 使用了花括号，但是不填入内容，执行结果和上面的完全一致
            // 生成了一个继承了Date类的子类的对象
        System.out.println(str2);
        System.out.println(&quot;----------------&quot;);

        // 使用匿名内部类，并且重写父类中的方法
        String str3 = test.getDate(new Date()
        {

            // 重写父类中的方法
            @Override
            @Deprecated
            public String toLocaleString()
            {
                return &quot;Hello: &quot; + super.toLocaleString();
            }

        });

        System.out.println(str3);
    }
}
</code></pre><p>　　生成的.class文件中，匿名类会生成OuterClass$1.class文件，数字根据是第几个匿名类而类推。</p>
<h1 id="u4E09_u3001_u5BB9_u5668_u6DF1_u5165_u7814_u7A76"><a href="#u4E09_u3001_u5BB9_u5668_u6DF1_u5165_u7814_u7A76" class="headerlink" title="三、容器深入研究"></a>三、容器深入研究</h1><p><img src="./collections.png" width="100%" height="100%"></p>
<h5 id="3-1__u6BCF_u4E2Ajava-util_u5BB9_u5668_u90FD_u6709_u81EA_u5DF1_u7684Abstract_u7C7B_uFF0C_u4ED6_u4EEC_u63D0_u4F9B_u4E86_u8BE5_u5BB9_u5668_u7684_u90E8_u5206_u5B9E_u73B0_uFF0C_u6240_u4EE5_u53EA_u8981_u53BB_u5B9E_u73B0_u90A3_u4E9B_u60F3_u8981_u7684_u5BB9_u5668_u6240_u5FC5_u987B_u7684_u65B9_u6CD5_uFF0C_u5C31_u53EF_u4EE5_u521B_u5EFA_u65B0_u7684_u5BB9_u5668"><a href="#3-1__u6BCF_u4E2Ajava-util_u5BB9_u5668_u90FD_u6709_u81EA_u5DF1_u7684Abstract_u7C7B_uFF0C_u4ED6_u4EEC_u63D0_u4F9B_u4E86_u8BE5_u5BB9_u5668_u7684_u90E8_u5206_u5B9E_u73B0_uFF0C_u6240_u4EE5_u53EA_u8981_u53BB_u5B9E_u73B0_u90A3_u4E9B_u60F3_u8981_u7684_u5BB9_u5668_u6240_u5FC5_u987B_u7684_u65B9_u6CD5_uFF0C_u5C31_u53EF_u4EE5_u521B_u5EFA_u65B0_u7684_u5BB9_u5668" class="headerlink" title="3.1 每个java.util容器都有自己的Abstract类，他们提供了该容器的部分实现，所以只要去实现那些想要的容器所必须的方法，就可以创建新的容器"></a>3.1 每个java.util容器都有自己的Abstract类，他们提供了该容器的部分实现，所以只要去实现那些想要的容器所必须的方法，就可以创建新的容器</h5><h5 id="3-2_Collection_u6267_u884C_u7684_u6240_u6709_u64CD_u4F5C"><a href="#3-2_Collection_u6267_u884C_u7684_u6240_u6709_u64CD_u4F5C" class="headerlink" title="3.2 Collection执行的所有操作"></a>3.2 Collection执行的所有操作</h5><ul>
<li>boolean add（T）确保容器持有具有泛型类型T的参数，如果没有将此参数添加进容器，则返回false</li>
<li>boolean addAll（Collection &lt;? extends T&gt;）添加参数中的所有元素，只要添加了任意元素就返回true</li>
<li>void clear（） 移除容器中的所有元素</li>
<li>boolean contains（T） 如果容器中已经持有泛型类型T此参数，则返回true</li>
<li>Boolean containsAll（Collection&lt;?&gt;）如果容器持有此参数中的所有元素,则返回true</li>
<li>boolean isEmpty()  容器中没有元素时返回true</li>
<li>Iterator<t> iterator()  返回一个Iterator<t> , 可以用来遍历容器中的元素</t></t></li>
<li>Boolean remove(Object)  如果参数在容器中,则移除此元素的一个实例,如果做了一处操作,则返回true</li>
<li>boolean removeAll(Collection&lt;?&gt;) 移除参数中的所有元素,只要有移除动作就返回true</li>
<li>Boolean retainAll(Collection&lt;?&gt;) 只保存参数中的元素,只要Collection发生了改变就返回true</li>
<li>int size() 返回容器中元素的数目</li>
<li>Object[]  toArray() 返回一个数组,该数组包含容器中的所有元素</li>
<li><t> T[] toArray(T[] a)返回一个数组该数组包含容器中的所有元素,返回结果的运行时类型参数与参数数组a的类型相同,而不是单纯的Object</t></li>
</ul>
<h5 id="3-3__u5C06_u65B9_u6CD5_u5B9A_u4E49_u4E3A_u53EF_u9009_2C_u90A3_u662F_u56E0_u4E3A_u8FD9_u6837_u505A_u53EF_u4EE5_u9632_u6B62_u5728_u8BBE_u8BA1_u4E2D_u51FA_u73B0_u63A5_u53E3_u7206_u70B8_u7684_u60C5_u51B5"><a href="#3-3__u5C06_u65B9_u6CD5_u5B9A_u4E49_u4E3A_u53EF_u9009_2C_u90A3_u662F_u56E0_u4E3A_u8FD9_u6837_u505A_u53EF_u4EE5_u9632_u6B62_u5728_u8BBE_u8BA1_u4E2D_u51FA_u73B0_u63A5_u53E3_u7206_u70B8_u7684_u60C5_u51B5" class="headerlink" title="3.3 将方法定义为可选,那是因为这样做可以防止在设计中出现接口爆炸的情况"></a>3.3 将方法定义为可选,那是因为这样做可以防止在设计中出现接口爆炸的情况</h5><h5 id="3-4_java_u5BB9_u5668_u7C7B_u5E93_u7684_u4E00_u4E2A_u91CD_u8981_u76EE_u6807_3A_u5BB9_u5668_u5E94_u8BE5_u6613_u5B66_u6613_u7528"><a href="#3-4_java_u5BB9_u5668_u7C7B_u5E93_u7684_u4E00_u4E2A_u91CD_u8981_u76EE_u6807_3A_u5BB9_u5668_u5E94_u8BE5_u6613_u5B66_u6613_u7528" class="headerlink" title="3.4 java容器类库的一个重要目标:容器应该易学易用"></a>3.4 java容器类库的一个重要目标:容器应该易学易用</h5><h5 id="3-5_UnsupportedOperationException_3A"><a href="#3-5_UnsupportedOperationException_3A" class="headerlink" title="3.5 UnsupportedOperationException:"></a>3.5 UnsupportedOperationException:</h5><ul>
<li>它必须是一个罕见的事件</li>
<li>如果一个操作是未获支持的,那么在实现接口的时候可以抛出这个异常</li>
</ul>
<h5 id="3-6__u5982_u679C_u4E00_u4E2A_u5BF9_u8C61_u88AB_u7528_u4E8E_u4EFB_u4F55_u79CD_u7C7B_u7684_u6392_u5E8F_u5BB9_u5668_u4E2D_uFF0C_u4F8B_u5982SortedSet_uFF08TreeSet_u662F_u5176_u552F_u4E00_u5B9E_u73B0_uFF09_uFF0C_u90A3_u4E48_u5B83_u5FC5_u987B_u5B9E_u73B0_u8FD9_u4E2A_u63A5_u53E3_u3002_u5B9E_u73B0_u5176_u4E2D_u7684compareTo_28_29_uFF0C_u5982_u679Cequals_uFF08_uFF09_u5BF9_u4E8E_u67D0_u4E2A_u7279_u5B9A_u6BD4_u8F83_u4EA7_u751Ftrue_uFF0C_u90A3_u4E48compareTo_uFF08_uFF09_u5BF9_u4E8E_u8BE5_u6BD4_u8F83_u5E94_u8BE5_u8FD4_u56DE0_uFF0C_u5982_u679Cequals_uFF08_uFF09_u5BF9_u4E8E_u67D0_u4E2A_u6BD4_u8F83_u4EA7_u751Ffalse_uFF0C_u90A3_u4E48compareTo_uFF08_uFF09_u5BF9_u4E8E_u8BE5_u6BD4_u8F83_u5E94_u8BE5_u8FD4_u56DE_u975E0_u503C"><a href="#3-6__u5982_u679C_u4E00_u4E2A_u5BF9_u8C61_u88AB_u7528_u4E8E_u4EFB_u4F55_u79CD_u7C7B_u7684_u6392_u5E8F_u5BB9_u5668_u4E2D_uFF0C_u4F8B_u5982SortedSet_uFF08TreeSet_u662F_u5176_u552F_u4E00_u5B9E_u73B0_uFF09_uFF0C_u90A3_u4E48_u5B83_u5FC5_u987B_u5B9E_u73B0_u8FD9_u4E2A_u63A5_u53E3_u3002_u5B9E_u73B0_u5176_u4E2D_u7684compareTo_28_29_uFF0C_u5982_u679Cequals_uFF08_uFF09_u5BF9_u4E8E_u67D0_u4E2A_u7279_u5B9A_u6BD4_u8F83_u4EA7_u751Ftrue_uFF0C_u90A3_u4E48compareTo_uFF08_uFF09_u5BF9_u4E8E_u8BE5_u6BD4_u8F83_u5E94_u8BE5_u8FD4_u56DE0_uFF0C_u5982_u679Cequals_uFF08_uFF09_u5BF9_u4E8E_u67D0_u4E2A_u6BD4_u8F83_u4EA7_u751Ffalse_uFF0C_u90A3_u4E48compareTo_uFF08_uFF09_u5BF9_u4E8E_u8BE5_u6BD4_u8F83_u5E94_u8BE5_u8FD4_u56DE_u975E0_u503C" class="headerlink" title="3.6 如果一个对象被用于任何种类的排序容器中，例如SortedSet（TreeSet是其唯一实现），那么它必须实现这个接口。实现其中的compareTo()，如果equals（）对于某个特定比较产生true，那么compareTo（）对于该比较应该返回0，如果equals（）对于某个比较产生false，那么compareTo（）对于该比较应该返回非0值"></a>3.6 如果一个对象被用于任何种类的排序容器中，例如SortedSet（TreeSet是其唯一实现），那么它必须实现这个接口。实现其中的compareTo()，如果equals（）对于某个特定比较产生true，那么compareTo（）对于该比较应该返回0，如果equals（）对于某个比较产生false，那么compareTo（）对于该比较应该返回非0值</h5><h5 id="3-7_LinkedHashSet_u6309_u7167_u5143_u7D20_u63D2_u5165_u7684_u987A_u5E8F_u4FDD_u5B58_u5143_u7D20_uFF0C_u800CTreeSet_u6309_u7167_u6392_u5E8F_u987A_u5E8F_u7EF4_u62A4_u5143_u7D20"><a href="#3-7_LinkedHashSet_u6309_u7167_u5143_u7D20_u63D2_u5165_u7684_u987A_u5E8F_u4FDD_u5B58_u5143_u7D20_uFF0C_u800CTreeSet_u6309_u7167_u6392_u5E8F_u987A_u5E8F_u7EF4_u62A4_u5143_u7D20" class="headerlink" title="3.7 LinkedHashSet按照元素插入的顺序保存元素，而TreeSet按照排序顺序维护元素"></a>3.7 LinkedHashSet按照元素插入的顺序保存元素，而TreeSet按照排序顺序维护元素</h5><h5 id="3-8_SortedSet_uFF1A"><a href="#3-8_SortedSet_uFF1A" class="headerlink" title="3.8 SortedSet："></a>3.8 SortedSet：</h5><ul>
<li>Comparator comparator（）返回当前set使用的Comparator，或者返回null，表示自然方式排序</li>
<li>Object first（）返回容器总的第一个元素</li>
<li>Object last（）返回容器中的最末一个元素</li>
<li>SortedSet subSet（fromElement， toElement）生成此Set的自己，范围从fromElement（包含）到toElement（不包含）</li>
<li>SortedSet headSet（toElement）生成此Set的子集，由小于toElement的元素组成</li>
<li>SortedSet tailSet（fromElement）生成此Set的子集，由大于或等于fromElement的元素组成</li>
</ul>
<h5 id="3-9_SortedSet_u7684_u610F_u601D_u662F_u201C_u6309_u5BF9_u8C61_u7684_u6BD4_u8F83_u51FD_u6570_u5BF9_u5143_u7D20_u6392_u5E8F_u201D_uFF0C_u800C_u4E0D_u662F_u6307_u201C_u5143_u7D20_u63D2_u5165_u7684_u6B21_u5E8F_u201D_u3002_u63D2_u5165_u987A_u5E8F_u53EF_u4EE5_u7528LinkedHashSet_u6765_u4FDD_u5B58"><a href="#3-9_SortedSet_u7684_u610F_u601D_u662F_u201C_u6309_u5BF9_u8C61_u7684_u6BD4_u8F83_u51FD_u6570_u5BF9_u5143_u7D20_u6392_u5E8F_u201D_uFF0C_u800C_u4E0D_u662F_u6307_u201C_u5143_u7D20_u63D2_u5165_u7684_u6B21_u5E8F_u201D_u3002_u63D2_u5165_u987A_u5E8F_u53EF_u4EE5_u7528LinkedHashSet_u6765_u4FDD_u5B58" class="headerlink" title="3.9 SortedSet的意思是“按对象的比较函数对元素排序”，而不是指“元素插入的次序”。插入顺序可以用LinkedHashSet来保存"></a>3.9 SortedSet的意思是“按对象的比较函数对元素排序”，而不是指“元素插入的次序”。插入顺序可以用LinkedHashSet来保存</h5><h5 id="3-10_Queue_u5728java_se5_u4E2D_u53EA_u6709_u4E24_u4E2A_u5B9E_u73B0_uFF0CLinkedList_u548CPriorityQueue_uFF0C_u4ED6_u4EEC_u7684_u5DEE_u5F02_u5728_u6392_u5E8F_u884C_u4E3A"><a href="#3-10_Queue_u5728java_se5_u4E2D_u53EA_u6709_u4E24_u4E2A_u5B9E_u73B0_uFF0CLinkedList_u548CPriorityQueue_uFF0C_u4ED6_u4EEC_u7684_u5DEE_u5F02_u5728_u6392_u5E8F_u884C_u4E3A" class="headerlink" title="3.10 Queue在java se5中只有两个实现，LinkedList和PriorityQueue，他们的差异在排序行为"></a>3.10 Queue在java se5中只有两个实现，LinkedList和PriorityQueue，他们的差异在排序行为</h5><ul>
<li>PriorityQueue的排序也是通过Comparable而进行控制</li>
</ul>
<h5 id="3-11__u53CC_u5411_u961F_u5217_uFF1A"><a href="#3-11__u53CC_u5411_u961F_u5217_uFF1A" class="headerlink" title="3.11 双向队列："></a>3.11 双向队列：</h5><ul>
<li>就像是一个队列，但是可以在任何一段添加或移除元素，在LinkedList中包含支持双向队列的方法，但是在java标准类库中没有任何显式地用于双向队列的接口。因此可以使用组合来创建一个Deque类，并直接从LinkedList中暴露</li>
</ul>
<h5 id="3-12__u6620_u5C04_u8868_uFF08_u4E5F_u79F0_u4E3A_u5173_u8054_u6570_u7EC4_uFF09_u7684_u57FA_u672C_u601D_u60F3_u662F_u5B83_u7EF4_u62A4_u7684_u662F_u952E_u503C_uFF08_u5BF9_uFF09_u5173_u8054_uFF0C_u56E0_u6B64_u4F60_u53EF_u4EE5_u4F7F_u7528_u952E_u6765_u67E5_u627E_u503C_u3002_u6807_u51C6_u7684java_u7C7B_u5E93_u4E2D_u5305_u542B_u4E86Map_u7684_u51E0_u79CD_u57FA_u672C_u5B9E_u73B0_uFF0C_u5305_u62EC"><a href="#3-12__u6620_u5C04_u8868_uFF08_u4E5F_u79F0_u4E3A_u5173_u8054_u6570_u7EC4_uFF09_u7684_u57FA_u672C_u601D_u60F3_u662F_u5B83_u7EF4_u62A4_u7684_u662F_u952E_u503C_uFF08_u5BF9_uFF09_u5173_u8054_uFF0C_u56E0_u6B64_u4F60_u53EF_u4EE5_u4F7F_u7528_u952E_u6765_u67E5_u627E_u503C_u3002_u6807_u51C6_u7684java_u7C7B_u5E93_u4E2D_u5305_u542B_u4E86Map_u7684_u51E0_u79CD_u57FA_u672C_u5B9E_u73B0_uFF0C_u5305_u62EC" class="headerlink" title="3.12 映射表（也称为关联数组）的基本思想是它维护的是键值（对）关联，因此你可以使用键来查找值。标准的java类库中包含了Map的几种基本实现，包括"></a>3.12 映射表（也称为关联数组）的基本思想是它维护的是键值（对）关联，因此你可以使用键来查找值。标准的java类库中包含了Map的几种基本实现，包括</h5><h6 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h6><p>使用了hashCode（）来进行散列，hashCode为java的Object根类的方法，插入和查询“键值对”的开销是固定的，可以通过构造器设置容量和负载因子，以调整容器的性能</p>
<ul>
<li>默认的Object.equals()比较的是对象的地址</li>
<li><p>HashMap使用equals（）判断当前键是否与表中存在的键相同，正确的equals应满足以下5个条件</p>
<pre><code>1. 自反性：x.equals(x) = true
2. 对称性：若x.equals(y)= true,则y.equals(x)=true
3. 传递性：对任意x，y，z若x.equals(y)=true,且y.equals(z)=true,则x.equals(z)=true
4. 一致性：对于任意x和y，如果对象中用于等价比较的信息没有改变，那么无论调用x.equals(y)多少次，返回结果总是一致地
5. 对任何不是null的x，x.equals(null)一定返回false
</code></pre></li>
<li>如果要使用自己的类作为HashMap的键，必须同时重载hashCode（）和equals（）方法</li>
</ul>
<h6 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h6><ul>
<li><p>基于树状结构的实现，查看“键”或“键值对”时，他们会被排序（次序由Comparable或Comparator）决定。TreeMap的特点在于，所得到的结果是经过排序的。TreeMap是唯一带有subMap（）方法的Map，可以返回一个子树</p>
<pre><code>1. Comparator comparator（）：返回当前Map使用的Comparator，如果返回null，表示以自然方式排序
2. T firstKey（）：返回Map中的第一个键
3. T lastKey（）：返回Map中的最末一个键
4. SortedMap subMap（fromKey，toKey）：生成此Map的子集，范围由fromKey（包含）到toKey（不包含）的键确定
5. SortedMap headMap（toKey）：生成此Map的子集，由键小于toKey（不包含）的键值对组成
6. SortedMap tailMap（fromKey）：生成此Map的子集，由键大于或等于fromKey的所有键值对组成
</code></pre></li>
</ul>
<h6 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h6><ul>
<li><p>类似于HahsMap，但是迭代遍历它取得“键值对”的顺序是其插入次序，或者是LRU次序，只比HashMap慢一点，而在迭代访问时反而更快，因为它使用链表维护内部次序</p>
<pre><code>1. 散列化所有的元素，但是在遍历键值对时，却又以元素的插入顺序返回键值对
2. 可以在构造器中设定LinkedHashMap，使之采用基于访问的最近最少使用（LRU）算法，没有访问过的元素就会出现在队列的前面
</code></pre></li>
</ul>
<h6 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h6><ul>
<li>弱键（weak key）映射，允许释放映射所指向的对象；这是为解决某类特殊问题而设计的。如果映射之外没有引用指向“某个键”，则此“键”将被GC回收</li>
</ul>
<h6 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h6><ul>
<li>一种线程安全的Map，他不涉及同步加锁</li>
</ul>
<h6 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h6><ul>
<li>使用==代替equals（）对“键”进行比较的散列映射，专门为解决特殊问题而设计的</li>
</ul>
<h5 id="3-13__u5982_u679C_u4E0D_u8986_u76D6hashCode_uFF08_uFF09_u548Cequals_uFF08_uFF09_u5C06_u65E0_u6CD5_u4F7F_u7528_u6563_u5217_u7684_u6570_u636E_u7ED3_u6784_u6709_uFF1A"><a href="#3-13__u5982_u679C_u4E0D_u8986_u76D6hashCode_uFF08_uFF09_u548Cequals_uFF08_uFF09_u5C06_u65E0_u6CD5_u4F7F_u7528_u6563_u5217_u7684_u6570_u636E_u7ED3_u6784_u6709_uFF1A" class="headerlink" title="3.13 如果不覆盖hashCode（）和equals（）将无法使用散列的数据结构有："></a>3.13 如果不覆盖hashCode（）和equals（）将无法使用散列的数据结构有：</h5><pre><code>1. HashSet
2. HashMap
3. LinkedHashSet
4. LinkedHashMap
</code></pre><h5 id="3-14__u6563_u5217_u7684_u4EF7_u503C_u5728_u4E8E_u901F_u5EA6_uFF1A_u4E09_u70C8_u58EB_u7684_u67E5_u8BE2_u5F97_u4EE5_u5FEB_u901F_u8FDB_u884C_u3002_u7531_u4E8E_u74F6_u9888_u4F4D_u4E8E_u952E_u7684_u67E5_u8BE2_u901F_u5EA6_u3002"><a href="#3-14__u6563_u5217_u7684_u4EF7_u503C_u5728_u4E8E_u901F_u5EA6_uFF1A_u4E09_u70C8_u58EB_u7684_u67E5_u8BE2_u5F97_u4EE5_u5FEB_u901F_u8FDB_u884C_u3002_u7531_u4E8E_u74F6_u9888_u4F4D_u4E8E_u952E_u7684_u67E5_u8BE2_u901F_u5EA6_u3002" class="headerlink" title="3.14 散列的价值在于速度：三烈士的查询得以快速进行。由于瓶颈位于键的查询速度。"></a>3.14 散列的价值在于速度：三烈士的查询得以快速进行。由于瓶颈位于键的查询速度。</h5><h5 id="3-15__u6563_u5217_u51B2_u7A81_uFF1A"><a href="#3-15__u6563_u5217_u51B2_u7A81_uFF1A" class="headerlink" title="3.15 散列冲突："></a>3.15 散列冲突：</h5><ul>
<li>如果能够保证没有冲突（如果值的数量是固定的，那么就有可能），那可就有了一个完美的散列函数</li>
<li>冲突由外部链接处理：数组并不直接保存值，而是保存值得list，然后对list中的值使用equals（）方法进行线性查询</li>
<li>为了使散列均匀分布，通常桶（槽）的数量为质数</li>
</ul>
<h5 id="3-16__u8BBE_u8BA1hashCode_uFF08_uFF09_u65F6_u6700_u91CD_u8981_u7684_u56E0_u7D20_u5C31_u662F_uFF1A_u65E0_u8BBA_u4F55_u65F6_uFF0C_u5BF9_u540C_u4E00_u4E2A_u5BF9_u8C61_uFF0C_u8C03_u7528hashCode_uFF08_uFF09_u90FD_u5E94_u8BE5_u751F_u6210_u540C_u6837_u7684_u503C"><a href="#3-16__u8BBE_u8BA1hashCode_uFF08_uFF09_u65F6_u6700_u91CD_u8981_u7684_u56E0_u7D20_u5C31_u662F_uFF1A_u65E0_u8BBA_u4F55_u65F6_uFF0C_u5BF9_u540C_u4E00_u4E2A_u5BF9_u8C61_uFF0C_u8C03_u7528hashCode_uFF08_uFF09_u90FD_u5E94_u8BE5_u751F_u6210_u540C_u6837_u7684_u503C" class="headerlink" title="3.16 设计hashCode（）时最重要的因素就是：无论何时，对同一个对象，调用hashCode（）都应该生成同样的值"></a>3.16 设计hashCode（）时最重要的因素就是：无论何时，对同一个对象，调用hashCode（）都应该生成同样的值</h5><h5 id="3-17_String_u7684hashCode_uFF08_uFF09_u751F_u6210_u7684_u540C_u6837_u7684_u7ED3_u679C"><a href="#3-17_String_u7684hashCode_uFF08_uFF09_u751F_u6210_u7684_u540C_u6837_u7684_u7ED3_u679C" class="headerlink" title="3.17 String的hashCode（）生成的同样的结果"></a>3.17 String的hashCode（）生成的同样的结果</h5><h5 id="3-18_Set_u53EF_u88AB_u5B9E_u73B0_u4E3A_uFF1A"><a href="#3-18_Set_u53EF_u88AB_u5B9E_u73B0_u4E3A_uFF1A" class="headerlink" title="3.18 Set可被实现为："></a>3.18 Set可被实现为：</h5><ul>
<li>TreeSet：HashSet最常用，查询速度最快。使用它原因是它可以维持元素的排序状态。TreeSet迭代通常比用HashSet要快</li>
<li>HashSet：基于TreeMap。生成一个总是处于排序状态的Set。性能基本上总是比TreeSet好，特别是在添加和查询元素时，而这两个操作也是最重要的操作。</li>
<li>LinkedHashSet：保持元素插入的次序。对于插入操作LinkedHashSet比HashSet的代价还高，这是由维护链表所带来额外开销造成的</li>
</ul>
<h5 id="3-19_Map_u53EF_u88AB_u5B9E_u73B0_u4E3A_uFF1A"><a href="#3-19_Map_u53EF_u88AB_u5B9E_u73B0_u4E3A_uFF1A" class="headerlink" title="3.19 Map可被实现为："></a>3.19 Map可被实现为：</h5><ul>
<li>IdentityHashMap：所有的Map实现的插入操作都会随着Map尺寸的变大而明显变慢。查找的代价通常比插入要小得多</li>
<li>HashTable的性能大体上与HashMap相当，HashMap是用来替代HashTable的</li>
<li>TreeMap：通常比HashMap慢，与TreeSet一样，TreeMap是一种创建有序队列的方式</li>
<li>LinkedHashMap：在插入时比HashMap慢一点，因为它维护散列数据结构的同时还要维护链表，正是由于这个列表，使得其迭代速度更快</li>
</ul>
<h5 id="3-20_HashMap_u7684_u6027_u80FD_u56E0_u5B50_uFF1A"><a href="#3-20_HashMap_u7684_u6027_u80FD_u56E0_u5B50_uFF1A" class="headerlink" title="3.20 HashMap的性能因子："></a>3.20 HashMap的性能因子：</h5><ul>
<li>容量：表中的桶位数</li>
<li>初始容量：表在创建时所拥有的桶位数。HashMap和HashSet都具有允许你指定初始容量的构造器</li>
<li>尺寸：表中当前存储的项数</li>
<li>负载因子：尺寸/容量</li>
</ul>
<h5 id="3-21_HashMap_u4F7F_u7528_u7684_u9ED8_u8BA4_u8D1F_u8F7D_u56E0_u5B500-75_uFF0C_u8FD9_u4E2A_u56E0_u5B50_u5728_u65F6_u95F4_u548C_u7A7A_u95F4_u4EE3_u4EF7_u4E4B_u95F4_u8FBE_u5230_u4E86_u5E73_u8861_uFF0C_u66F4_u9AD8_u7684_u8D1F_u8F7D_u56E0_u5B50_u53EF_u4EE5_u964D_u4F4E_u8868_u6240_u9700_u7684_u7A7A_u95F4_uFF0C_u4F46_u662F_u4F1A_u589E_u52A0_u67E5_u627E_u4EE3_u4EF7"><a href="#3-21_HashMap_u4F7F_u7528_u7684_u9ED8_u8BA4_u8D1F_u8F7D_u56E0_u5B500-75_uFF0C_u8FD9_u4E2A_u56E0_u5B50_u5728_u65F6_u95F4_u548C_u7A7A_u95F4_u4EE3_u4EF7_u4E4B_u95F4_u8FBE_u5230_u4E86_u5E73_u8861_uFF0C_u66F4_u9AD8_u7684_u8D1F_u8F7D_u56E0_u5B50_u53EF_u4EE5_u964D_u4F4E_u8868_u6240_u9700_u7684_u7A7A_u95F4_uFF0C_u4F46_u662F_u4F1A_u589E_u52A0_u67E5_u627E_u4EE3_u4EF7" class="headerlink" title="3.21 HashMap使用的默认负载因子0.75，这个因子在时间和空间代价之间达到了平衡，更高的负载因子可以降低表所需的空间，但是会增加查找代价"></a>3.21 HashMap使用的默认负载因子0.75，这个因子在时间和空间代价之间达到了平衡，更高的负载因子可以降低表所需的空间，但是会增加查找代价</h5><h5 id="3-22_Java_u5BB9_u5668_u7C7B_u7C7B_u5E93_u91C7_u7528_u5FEB_u901F_u62A5_u9519_u673A_u5236_u3002_u5FEB_u901F_u62A5_u9519_u673A_u5236_u7684_u5DE5_u4F5C_u539F_u7406_uFF1A_u53EA_u9700_u521B_u5EFA_u4E00_u4E2A_u8FED_u4EE3_u5668_uFF0C_u7136_u540E_u5411_u8FED_u4EE3_u5668_u6240_u6307_u5411_u7684Collection_u6DFB_u52A0_u70B9_u4EC0_u4E48"><a href="#3-22_Java_u5BB9_u5668_u7C7B_u7C7B_u5E93_u91C7_u7528_u5FEB_u901F_u62A5_u9519_u673A_u5236_u3002_u5FEB_u901F_u62A5_u9519_u673A_u5236_u7684_u5DE5_u4F5C_u539F_u7406_uFF1A_u53EA_u9700_u521B_u5EFA_u4E00_u4E2A_u8FED_u4EE3_u5668_uFF0C_u7136_u540E_u5411_u8FED_u4EE3_u5668_u6240_u6307_u5411_u7684Collection_u6DFB_u52A0_u70B9_u4EC0_u4E48" class="headerlink" title="3.22 Java容器类类库采用快速报错机制。快速报错机制的工作原理：只需创建一个迭代器，然后向迭代器所指向的Collection添加点什么"></a>3.22 Java容器类类库采用快速报错机制。快速报错机制的工作原理：只需创建一个迭代器，然后向迭代器所指向的Collection添加点什么</h5><h5 id="3-23_java-lang-ref_u7C7B_u5E93_u5305_u542B_u4E86_u4E00_u7EC4_u7C7B_uFF0C_u6709_u4E09_u4E2A_u7EE7_u627F_u81EA_u62BD_u8C61_u7C7BReference_u7684_u7C7B_uFF1ASoftReference_uFF0CWeakReference_u548CPhantomReference_u3002_u5F53_u5783_u573E_u56DE_u6536_u5668_u6B63_u5728_u8003_u5BDF_u7684_u5BF9_u8C61_u53EA_u80FD_u901A_u8FC7_u67D0_u4E2AReference_u5BF9_u8C61_u624D_u201C_u53EF_u83B7_u5F97_u201D_u65F6_uFF0C_u4E0A_u8FF0_u8FD9_u4E9B_u4E0D_u540C_u7684_u6D3E_u751F_u7C7B_u4E3A_u5783_u573E_u56DE_u6536_u5668_u63D0_u4F9B_u4E86_u4E0D_u540C_u7EA7_u522B_u7684_u95F4_u63A5_u6027_u53EA_u662F_u3002"><a href="#3-23_java-lang-ref_u7C7B_u5E93_u5305_u542B_u4E86_u4E00_u7EC4_u7C7B_uFF0C_u6709_u4E09_u4E2A_u7EE7_u627F_u81EA_u62BD_u8C61_u7C7BReference_u7684_u7C7B_uFF1ASoftReference_uFF0CWeakReference_u548CPhantomReference_u3002_u5F53_u5783_u573E_u56DE_u6536_u5668_u6B63_u5728_u8003_u5BDF_u7684_u5BF9_u8C61_u53EA_u80FD_u901A_u8FC7_u67D0_u4E2AReference_u5BF9_u8C61_u624D_u201C_u53EF_u83B7_u5F97_u201D_u65F6_uFF0C_u4E0A_u8FF0_u8FD9_u4E9B_u4E0D_u540C_u7684_u6D3E_u751F_u7C7B_u4E3A_u5783_u573E_u56DE_u6536_u5668_u63D0_u4F9B_u4E86_u4E0D_u540C_u7EA7_u522B_u7684_u95F4_u63A5_u6027_u53EA_u662F_u3002" class="headerlink" title="3.23 java.lang.ref类库包含了一组类，有三个继承自抽象类Reference的类：SoftReference，WeakReference和PhantomReference。当垃圾回收器正在考察的对象只能通过某个Reference对象才“可获得”时，上述这些不同的派生类为垃圾回收器提供了不同级别的间接性只是。"></a>3.23 java.lang.ref类库包含了一组类，有三个继承自抽象类Reference的类：SoftReference，WeakReference和PhantomReference。当垃圾回收器正在考察的对象只能通过某个Reference对象才“可获得”时，上述这些不同的派生类为垃圾回收器提供了不同级别的间接性只是。</h5><h5 id="3-24__u5BF9_u8C61_u662F_u53EF_u83B7_u5F97_u7684_uFF0C_u662F_u6307_u6B64_u5BF9_u8C61_u53EF_u5728_u7A0B_u5E8F_u4E2D_u7684_u67D0_u5904_u627E_u8349_uFF0C_u8FD9_u610F_u5473_u7740_u4F60_u5728_u6808_u4E2D_u6709_u4E00_u4E2A_u666E_u901A_u7684_u5F15_u7528_uFF0C_u800C_u5B83_u6B63_u6307_u5411_u6B64_u5BF9_u8C61_u3002_u5982_u679C_u4E00_u4E2A_u5BF9_u8C61_u662F_u201C_u53EF_u83B7_u5F97_u7684_u201D_uFF0C_u5783_u573E_u56DE_u6536_u5668_u5C31_u4E0D_u80FD_u91CA_u653E_u5B83_uFF0C_u56E0_u4E3A_u5B83_u4ECD_u7136_u4E3A_u4F60_u7684_u7A0B_u5E8F_u6240_u7528_u3002_u5982_u679C_u4E00_u4E2A_u5BF9_u8C61_u4E0D_u662F_u201C_u53EF_u83B7_u5F97_u7684_u201D_uFF0C_u90A3_u4E48_u4F60_u7684_u7A0B_u5E8F_u65E0_u6CD5_u4F7F_u7528_u5230_u5B83_uFF0C_u6240_u6709_u5C06_u5176_u56DE_u6536_u662F_u5B89_u5168_u7684"><a href="#3-24__u5BF9_u8C61_u662F_u53EF_u83B7_u5F97_u7684_uFF0C_u662F_u6307_u6B64_u5BF9_u8C61_u53EF_u5728_u7A0B_u5E8F_u4E2D_u7684_u67D0_u5904_u627E_u8349_uFF0C_u8FD9_u610F_u5473_u7740_u4F60_u5728_u6808_u4E2D_u6709_u4E00_u4E2A_u666E_u901A_u7684_u5F15_u7528_uFF0C_u800C_u5B83_u6B63_u6307_u5411_u6B64_u5BF9_u8C61_u3002_u5982_u679C_u4E00_u4E2A_u5BF9_u8C61_u662F_u201C_u53EF_u83B7_u5F97_u7684_u201D_uFF0C_u5783_u573E_u56DE_u6536_u5668_u5C31_u4E0D_u80FD_u91CA_u653E_u5B83_uFF0C_u56E0_u4E3A_u5B83_u4ECD_u7136_u4E3A_u4F60_u7684_u7A0B_u5E8F_u6240_u7528_u3002_u5982_u679C_u4E00_u4E2A_u5BF9_u8C61_u4E0D_u662F_u201C_u53EF_u83B7_u5F97_u7684_u201D_uFF0C_u90A3_u4E48_u4F60_u7684_u7A0B_u5E8F_u65E0_u6CD5_u4F7F_u7528_u5230_u5B83_uFF0C_u6240_u6709_u5C06_u5176_u56DE_u6536_u662F_u5B89_u5168_u7684" class="headerlink" title="3.24 对象是可获得的，是指此对象可在程序中的某处找草，这意味着你在栈中有一个普通的引用，而它正指向此对象。如果一个对象是“可获得的”，垃圾回收器就不能释放它，因为它仍然为你的程序所用。如果一个对象不是“可获得的”，那么你的程序无法使用到它，所有将其回收是安全的"></a>3.24 对象是可获得的，是指此对象可在程序中的某处找草，这意味着你在栈中有一个普通的引用，而它正指向此对象。如果一个对象是“可获得的”，垃圾回收器就不能释放它，因为它仍然为你的程序所用。如果一个对象不是“可获得的”，那么你的程序无法使用到它，所有将其回收是安全的</h5><h5 id="3-25_SoftReference_u3001WeakReference_u548CPhantomReference_u7531_u5F3A_u5230_u5F31_u6392_u5217_uFF0C_u5BF9_u5E94_u4E0D_u540C_u7EA7_u522B_u7684_u201C_u53EF_u83B7_u5F97_u6027_u201D"><a href="#3-25_SoftReference_u3001WeakReference_u548CPhantomReference_u7531_u5F3A_u5230_u5F31_u6392_u5217_uFF0C_u5BF9_u5E94_u4E0D_u540C_u7EA7_u522B_u7684_u201C_u53EF_u83B7_u5F97_u6027_u201D" class="headerlink" title="3.25 SoftReference、WeakReference和PhantomReference由强到弱排列，对应不同级别的“可获得性”"></a>3.25 SoftReference、WeakReference和PhantomReference由强到弱排列，对应不同级别的“可获得性”</h5><ul>
<li>SoftReference：用以实现内存敏感的高速缓存</li>
<li>WeakReference：为实现“规范映射”而设计的，它不妨碍垃圾回收器回收映射的“键”（或“值”）。规范映射中对象的实例可以在程序的多处被同时使用，以节省存储空间</li>
<li>PhantomReference：用一调度会收钱的清理工作，它比Java终止机制更灵活</li>
</ul>
<h1 id="u56DB_u3001_u5E76_u53D1"><a href="#u56DB_u3001_u5E76_u53D1" class="headerlink" title="四、并发"></a>四、并发</h1><h3 id="4-1__u4EC0_u4E48_u662F_u5E76_u53D1_u95EE_u9898"><a href="#4-1__u4EC0_u4E48_u662F_u5E76_u53D1_u95EE_u9898" class="headerlink" title="4.1 什么是并发问题"></a>4.1 什么是并发问题</h3><ul>
<li>多个进程或线程同时(或着说在同一段时间内)访问同一资源会产生并发问题。</li>
<li>银行两操作员同时操作同一账户就是典型的例子。比如A、B操作员同时读取一余额为1000元的账户，A操作员为该账户增加100元，B操作员同时为该账户减去 50元，A先提交，B后提交。 最后实际账户余额为1000-50=950元，但本该为 1000+100-50=1050。这就是典型的并发问题。如何解决？可以用锁。</li>
</ul>
<h3 id="4-2_java_u4E2Dsynchronized_u7684_u7528_u6CD5"><a href="#4-2_java_u4E2Dsynchronized_u7684_u7528_u6CD5" class="headerlink" title="4.2 java中synchronized的用法"></a>4.2 java中synchronized的用法</h3><ul>
<li><p>4.2.1 用法1</p>
<pre><code>public class Test{
public synchronized void print(){
        ....;
    } 
}
</code></pre><p>某线程执行print()方法，则该对象将加锁。其它线程将无法执行该对象的所有synchronized块。</p>
</li>
<li><p>4.2.2 用法2</p>
<pre><code>public class Test{
    public void print(){
        synchronized(this){//锁住本对象
            ...;
        }
    }
}
</code></pre><p>同用法1, 但更能体现synchronized用法的本质。</p>
</li>
<li><p>4.2.3 用法3</p>
<pre><code>public class Test{
    private String a = &quot;test&quot;;
    public void print(){
        synchronized(a){//锁住a对象
            ...;
        }
    }
    public synchronized void t(){
        ...; //这个同步代码块不会因为print()而锁定.
    }
}
</code></pre><p>执行print()，会给对象a加锁，注意不是给Test的对象加锁，也就是说 Test对象的其它synchronized方法不会因为print()而被锁。同步代码块执行完，则释放对a的锁。<br>为了锁住一个对象的代码块而不影响该对象其它 synchronized块的高性能写法：</p>
<pre><code>public class Test{
    private byte[] lock = new byte[0];
    public void print(){
        synchronized(lock){
            ...;
        }
    }
    public synchronized void t(){
        ...; 
    }
}
</code></pre></li>
<li><p>4.2.4 静态方法的锁</p>
<pre><code>public class Test{
public synchronized static void execute(){
        ...;
    }
}
效果同
public class Test{
    public static void execute(){
        synchronized(TestThread.class){
            ...;
        }
    }
}
</code></pre></li>
</ul>
<h3 id="4-3_Java_u4E2D_u7684_u9501_u4E0E_u6392_u961F_u4E0A_u5395_u6240_u3002"><a href="#4-3_Java_u4E2D_u7684_u9501_u4E0E_u6392_u961F_u4E0A_u5395_u6240_u3002" class="headerlink" title="4.3 Java中的锁与排队上厕所。"></a>4.3 Java中的锁与排队上厕所。</h3><ul>
<li><p>锁就是阻止其它进程或线程进行资源访问的一种方式，即锁住的资源不能被其它请求访问。在JAVA中，sychronized关键字用来对一个对象加锁。比如:</p>
<pre><code>public class MyStack {
    int idx = 0;
    char [] data = new char[6];

    public synchronized void push(char c) {
        data[idx] = c;
        idx++;
    }

    public synchronized char pop() {
        idx--;
        return data[idx];
    }

    public static void main(String args[]){
        MyStack m = new MyStack();
        /**
           下面对象m被加锁。严格的说是对象m的所有synchronized块被加锁。
           如果存在另一个试图访问m的线程T，那么T无法执行m对象的push和
           pop方法。
        */
        m.pop();//对象m被加锁。
    }
}
</code></pre></li>
<li>Java的加锁解锁跟多个人排队等一个公共厕位完全一样。第一个人进去后顺手把门从里面锁住，其它人只好排队等。第一个人结束后出来时，门才会打开（解锁）。轮到第二个人进去，同样他又会把门从里面锁住，其它人继续排队等待。</li>
<li><p>用厕所理论可以很容易明白: 一个人进了一个厕位，这个厕位就会锁住，但不会导致另一个厕位也被锁住，因为一个人不能同时蹲在两个厕位里。对于Java 就是说：Java中的锁是针对同一个对象的，不是针对class的。看下例：</p>
<pre><code>MyStatck m1 = new MyStack();
MyStatck m2 = new Mystatck();
m1.pop();
m2.pop();  
</code></pre><p>  m1对象的锁是不会影响m2的锁的，因为它们不是同一个厕位。就是说，假设有 3线程t1,t2,t3操作m1，那么这3个线程只可能在m1上排队等，假设另2个线程 t4,t5在操作m2，那么t4,t5只会在m2上等待。而t2和t4则没有关系，即使m2上的锁释放了，t1,t2,t3可能仍要在m1上排队。</p>
</li>
</ul>
<h3 id="4-4__u4F55_u65F6_u91CA_u653E_u9501_uFF1F"><a href="#4-4__u4F55_u65F6_u91CA_u653E_u9501_uFF1F" class="headerlink" title="4.4 何时释放锁？"></a>4.4 何时释放锁？</h3><ul>
<li><p>一般是执行完毕同步代码块（锁住的代码块）后就释放锁，也可以用wait()方式半路上释放锁。wait()方式就好比蹲厕所到一半，突然发现下水道堵住了，不得已必须出来站在一边，好让修下水道师傅(准备执行notify的一个线程）进去疏通马桶，疏通完毕，师傅大喊一声: “已经修好了”(notify)，刚才出来的同志听到后就重新排队。注意啊，必须等师傅出来啊，师傅不出来，谁也进不去。也就是说notify后，不是其它线程马上可以进入封锁区域活动了，而是必须还要等notify代码所在的封锁区域执行完毕从而释放锁以后，其它线程才可进入。<br>这里是wait与notify代码示例：</p>
<pre><code>public synchronized char pop() {
    char c;
    while (buffer.size() == 0) {
        try {
            this.wait(); //从厕位里出来
        } catch (InterruptedException e) {
            // ignore it...
        }
    }
    c = ((Character)buffer.remove(buffer.size()-1)).
        charValue();
    return c;
}

public synchronized void push(char c) {
    this.notify(); //通知那些wait()的线程重新排队。注意：仅仅是通知它们重新排队。
    Character charObj = new Character(c);
    buffer.addElement(charObj);
}//执行完毕，释放锁。那些排队的线程就可以进来了。
</code></pre><p>再深入一些：</p>
</li>
<li><p>由于wait()操作而半路出来的同志没收到notify信号前是不会再排队的，他会在旁边看着这些排队的人(其中修水管师傅也在其中）。注意，修水管的师傅不能插队，也得跟那些上厕所的人一样排队，不是说一个人蹲了一半出来后，修水管师傅就可以突然冒出来然后立刻进去抢修了，他要和原来排队的那帮人公平竞争，因为他也是个普通线程。如果修水管师傅排在后面，则前面的人进去后，发现堵了，就wait，然后出来站到一边，再进去一个，再wait，出来，站到一边，只到师傅进去执行notify. 这样，一会儿功夫，排队的旁边就站了一堆人，等着notify.<br>终于，师傅进去，然后notify了，接下来呢？</p>
<pre><code>1. 有一个wait的人（线程）被通知到。
2. 为什么被通知到的是他而不是另外一个wait的人？取决于JVM.我们无法预先判断出哪一个会被通知到。也就是说，优先级高的不一定被优先唤醒，等待时间长的也不一定被优先唤醒，一切不可预知！(当然，如果你了解该JVM的实现，则可以预知）。
3. 他（被通知到的线程）要重新排队。
4. 他会排在队伍的第一个位置吗？回答是：不一定。他会排最后吗？也不一定。
</code></pre><p> 但如果该线程优先级设的比较高，那么他排在前面的概率就比较大。</p>
<pre><code>5. 轮到他重新进入厕位时，他会从上次wait()的地方接着执行，不会重新执行。
6. 如果师傅notifyAll(). 则那一堆半途而废出来的人全部重新排队。顺序不可知。
</code></pre></li>
</ul>
<h3 id="4-5_Lock_u7684_u4F7F_u7528"><a href="#4-5_Lock_u7684_u4F7F_u7528" class="headerlink" title="4.5 Lock的使用"></a>4.5 Lock的使用</h3><ul>
<li>用synchronized关键字可以对资源加锁。用Lock关键字也可以。它是JDK1.5中新增内容。用法如下：</li>
</ul>
<pre><code>  class BoundedBuffer {

    final Lock lock = new ReentrantLock();
     final Condition notFull  = lock.newCondition(); 
     final Condition notEmpty = lock.newCondition(); 

     final Object[] items = new Object[100];
     int putptr, takeptr, count;

     public void put(Object x) throws InterruptedException {
         lock.lock();
         try {
             while (count == items.length) 
                 notFull.await();
             items[putptr] = x; 
             if (++putptr == items.length) putptr = 0;
             ++count;
             notEmpty.signal();
         } finally {
             lock.unlock();
         }
     }

     public Object take() throws InterruptedException {
         lock.lock();
         try {
             while (count == 0) 
                 notEmpty.await();
             Object x = items[takeptr]; 
             if (++takeptr == items.length) takeptr = 0;
             --count;
             notFull.signal();
             return x;
         } finally {
             lock.unlock();
         }
     } 
   }

(注：这是JavaDoc里的例子，是一个阻塞队列的实现例子。所谓阻塞队列，就是一个队列如果满了或者空了，都会导致线程阻塞等待。Java里的 ArrayBlockingQueue提供了现成的阻塞队列，不需要自己专门再写一个了。)
</code></pre><p>一个对象的lock.lock()和lock.unlock()之间的代码将会被锁住。这种方式比起synchronize好在什么地方？简而言之，就是对wait的线程进行了分类。用厕位理论来描述，则是那些蹲了一半而从厕位里出来等待的人原因可能不一样，有的是因为马桶堵了，有的是因为马桶没水了。通知(notify)的时候，就可以喊：因为马桶堵了而等待的过来重新排队（比如马桶堵塞问题被解决了），或者喊，因为马桶没水而等待的过来重新排队(比如马桶没水问题被解决了）。这样可以控制得更精细一些。不像synchronize里的wait和notify，不管是马桶堵塞还是马桶没水都只能喊：刚才等待的过来排队！假如排队的人进来一看，发现原来只是马桶堵塞问题解决了，而自己渴望解决的问题（马桶没水）还没解决，只好再回去等待(wait)，白进来转一圈，浪费时间与资源。</p>
<ul>
<li><p>Lock方式与synchronized对应关系：</p>
<pre><code>Lock    await      signal     signalAll
synchronized     wait     notify    notifyAll
</code></pre><p>注意：不要在Lock方式锁住的块里调用wait、notify、notifyAll</p>
</li>
</ul>
<h3 id="4-6__u5229_u7528_u7BA1_u9053_u8FDB_u884C_u7EBF_u7A0B_u95F4_u901A_u4FE1"><a href="#4-6__u5229_u7528_u7BA1_u9053_u8FDB_u884C_u7EBF_u7A0B_u95F4_u901A_u4FE1" class="headerlink" title="4.6 利用管道进行线程间通信"></a>4.6 利用管道进行线程间通信</h3><ul>
<li><p>原理简单。两个线程，一个操作PipedInputStream,一个操作 PipedOutputStream。PipedOutputStream写入的数据先缓存在Buffer中,如果 Buffer满，此线程wait。PipedInputStream读出Buffer中的数据，如果Buffer 没数据，此线程wait。<br>jdk1.5中的阻塞队列可实现同样功能。</p>
<pre><code>例1 这个例子实际上只是单线程，还谈不上线程间通信，但不妨一看。
http://hi.baidu.com/ecspell/blog/item/7b02d3133ab555005aaf53f5.html
package io;
import java.io.*;
public class PipedStreamTest {
    public static void main(String[] args) {
        PipedOutputStream ops=new PipedOutputStream();
        PipedInputStream pis=new PipedInputStream();
        try{
            ops.connect(pis);//实现管道连接
            new Producer(ops).run();
            new Consumer(pis).run();
        }catch(Exception e){
            e.printStackTrace();
        }

    }
}

//生产者
class Producer implements Runnable{
    private PipedOutputStream ops;
    public Producer(PipedOutputStream ops)
    {
        this.ops=ops;
    }

    public void run()
    {
        try{
            ops.write(&quot;hell,spell&quot;.getBytes());
            ops.close();
        }catch(Exception e)
            {e.printStackTrace();}
    }
}

//消费者
class Consumer implements Runnable{
    private PipedInputStream pis;
    public Consumer(PipedInputStream pis)
    {
        this.pis=pis;
    }

    public void run()
    {
        try{
            byte[] bu=new byte[100];
            int len=pis.read(bu);
            System.out.println(new String(bu,0,len));
            pis.close();
        }catch(Exception e)
            {e.printStackTrace();}
    }
} 
例2 对上面的程序做少许改动就成了两个线程。
package io;
import java.io.*;
public class PipedStreamTest {
    public static void main(String[] args) {
        PipedOutputStream ops=new PipedOutputStream();
        PipedInputStream pis=new PipedInputStream();
        try{
            ops.connect(pis);//实现管道连接
            Producer p = new Producer(ops);
            new Thread(p).start();
            Consumer c = new Consumer(pis);
            new Thread(c).start();
        }catch(Exception e){
            e.printStackTrace();
        }

    }
}

//生产者
class Producer implements Runnable{
    private PipedOutputStream ops;
    public Producer(PipedOutputStream ops)
    {
        this.ops=ops;
    }

    public void run()
    {
        try{
            for(;;){
                ops.write(&quot;hell,spell&quot;.getBytes());
                ops.close();
            }
        }catch(Exception e)
            {e.printStackTrace();}
    }
}

//消费者
class Consumer implements Runnable{
    private PipedInputStream pis;
    public Consumer(PipedInputStream pis)
    {
        this.pis=pis;
    }

    public void run()
    {
        try{
            for(;;){
                byte[] bu=new byte[100];
                int len=pis.read(bu);
                System.out.println(new String(bu,0,len));
            }
            pis.close();
        }catch(Exception e)
            {e.printStackTrace();}
    }
}
例3. 这个例子更加贴进应用
import java.io.*;

public class PipedIO { //程序运行后将sendFile文件的内容拷贝到receiverFile文件中
    public static void main(String args[]){       
        try{//构造读写的管道流对象       
            PipedInputStream pis=new PipedInputStream();       
            PipedOutputStream pos=new PipedOutputStream();       
            //实现关联       
            pos.connect(pis);       
            //构造两个线程，并且启动。           
            new Sender(pos,&quot;c:\\text2.txt&quot;).start();           
            new Receiver(pis,&quot;c:\\text3.txt&quot;).start();         
        }catch(IOException e){       
            System.out.println(&quot;Pipe Error&quot;+ e);       
        }       
    }       
}       
//线程发送       
class Sender extends Thread{           
    PipedOutputStream pos;       
    File file;       
    //构造方法       
    Sender(PipedOutputStream pos, String fileName){       
        this.pos=pos;       
        file=new File(fileName);       
    }          
    //线程运行方法       
    public void run(){          
        try{       
            //读文件内容       
            FileInputStream fs=new FileInputStream(file);       
            int data;       
            while((data=fs.read())!=-1){       
                //写入管道始端       
                pos.write(data);       
            }       
            pos.close();                        
        }       
        catch(IOException e) {       
            System.out.println(&quot;Sender Error&quot; +e);       
        }       
    }       
}

//线程读       
class Receiver extends Thread{       
    PipedInputStream pis;       
    File file;       
    //构造方法       
    Receiver(PipedInputStream pis, String fileName){         
        this.pis=pis;       
        file=new File(fileName);       
    }          
    //线程运行       
    public void run(){          
        try {       
            //写文件流对象       
            FileOutputStream fs=new FileOutputStream(file);       
            int data;       
            //从管道末端读       
            while((data=pis.read())!=-1){

                //写入本地文件       
                fs.write(data);       
            }       
            pis.close();            
        }       
        catch(IOException e){       
            System.out.println(&quot;Receiver Error&quot; +e);       
        }       
    }       
}
</code></pre></li>
</ul>
<h3 id="4-7__u963B_u585E_u961F_u5217"><a href="#4-7__u963B_u585E_u961F_u5217" class="headerlink" title="4.7 阻塞队列"></a>4.7 阻塞队列</h3><ul>
<li><p>阻塞队列可以代替管道流方式来实现进水管/排水管模式（生产者/消费者).JDK1.5提供了几个现成的阻塞队列. 现在来看ArrayBlockingQueue的代码如下：</p>
<pre><code>这里是一个阻塞队列
BlockingQueue&lt;Object&gt; blockingQ = new ArrayBlockingQueue&lt;Object&gt; 10;
一个线程从队列里取
for(;;){
    Object o = blockingQ.take();//队列为空，则等待（阻塞）
}
另一个线程往队列存
for(;;){
    blockingQ.put(new Object());//队列满，则等待（阻塞）
}
可见，阻塞队列使用起来比管道简单。
</code></pre></li>
</ul>
<h3 id="4-8__u4F7F_u7528Executors_u3001Executor_u3001ExecutorService_u3001ThreadPoolExecutor"><a href="#4-8__u4F7F_u7528Executors_u3001Executor_u3001ExecutorService_u3001ThreadPoolExecutor" class="headerlink" title="4.8 使用Executors、Executor、ExecutorService、ThreadPoolExecutor"></a>4.8 使用Executors、Executor、ExecutorService、ThreadPoolExecutor</h3><p>可以使用线程管理任务。还可以使用jdk1.5提供的一组类来更方便的管理任务。从这些类里我们可以体会一种面向任务的思维方式。这些类是：</p>
<ul>
<li><p>4.8.1 Executor接口。使用方法：</p>
<pre><code>Executor executor = anExecutor;//生成一个Executor实例。
executor.execute(new RunnableTask1());
</code></pre><p>用意：使用者只关注任务执行，不用操心去关注任务的创建、以及执行细节等这些第三方实现者关心的问题。也就是说，把任务的调用执行和任务的实现解耦。<br>实际上，JDK1.5中已经有该接口出色的实现。够用了。</p>
</li>
<li>4.8.2 Executors是一个如同Collections一样的工厂类或工具类，用来产生各种不同接口的实例。</li>
<li><p>4.8.3 ExecutorService接口它继承自Executor. Executor只管把任务扔进 executor()里去执行，剩余的事就不管了。而ExecutorService则不同，它会多做点控制工作。比如：</p>
<pre><code>class NetworkService {
    private final ServerSocket serverSocket;
    private final ExecutorService pool;

    public NetworkService(int port, int poolSize) throws IOException {
        serverSocket = new ServerSocket(port);
        pool = Executors.newFixedThreadPool(poolSize);
    }

    public void serve() {
        try {
            for (;;) {
                pool.execute(new Handler(serverSocket.accept()));
            }
        } catch (IOException ex) {
            pool.shutdown(); //不再执行新任务
        }
    }
}

class Handler implements Runnable {
    private final Socket socket;
    Handler(Socket socket) { this.socket = socket; }
    public void run() {
        // read and service request
    }
}
</code></pre><p>ExecutorService(也就是代码里的pool对象）执行shutdown后，它就不能再执行新任务了，但老任务会继续执行完毕，那些等待执行的任务也不再等待了。</p>
</li>
<li><p>4.8.4 任务提交者与执行者通讯</p>
<pre><code>public static void main(String args[])throws Exception {
    ExecutorService executor = Executors.newSingleThreadExecutor();
    Callable&lt;String&gt; task = new Callable&lt;String&gt;(){
        public String call()throws Exception{
            return &quot;test&quot;;
        }
    };
    Future&lt;String&gt; f = executor.submit(task); 
    String result = f.get();//等待（阻塞）返回结果
    System.out.println(result);
    executor.shutdown();                
}
Executors.newSingleThreadExecutor()取得的Executor实例有以下特性:
任务顺序执行. 比如：
executor.submit(task1);
executor.submit(task2);
必须等task1执行完，task2才能执行。
task1和task2会被放入一个队列里，由一个工作线程来处理。即：一共有2个线程(主线程、处理任务的工作线程）。
</code></pre></li>
</ul>
<h3 id="4-9__u5E76_u53D1_u6D41_u7A0B_u63A7_u5236"><a href="#4-9__u5E76_u53D1_u6D41_u7A0B_u63A7_u5236" class="headerlink" title="4.9 并发流程控制"></a>4.9 并发流程控制</h3><h5 id="4-9-1_CountDownLatch__u95E8_u63D2_u9500_u8BA1_u6570_u5668"><a href="#4-9-1_CountDownLatch__u95E8_u63D2_u9500_u8BA1_u6570_u5668" class="headerlink" title="4.9.1 CountDownLatch 门插销计数器"></a>4.9.1 CountDownLatch 门插销计数器</h5><ul>
<li><p>启动线程，然后等待线程结束。即常用的主线程等所有子线程结束后再执行的问题。</p>
<pre><code>public static void main(String[] args)throws Exception {
    // TODO Auto-generated method stub
    final int count=10;
    final CountDownLatch completeLatch = new CountDownLatch(count);//定义了门插销的数目是10

    for(int i=0;i&lt;count;i++){
        Thread thread = new Thread(&quot;worker thread&quot;+i){
                public void run(){
                    //do xxxx                                   
                    completeLatch.countDown();//减少一根门插销
                }
            };
        thread.start();
    }           
    completeLatch.await();//如果门插销还没减完则等待。
} 
</code></pre><p>JDK1.4时，常用办法是给子线程设置状态，主线程循环检测。易用性和效率都不好。</p>
</li>
<li><p>启动很多线程，等待通知才能开始</p>
<pre><code>public static void main(String[] args) throws Exception {
    // TODO Auto-generated method stub
    final CountDownLatch startLatch = new CountDownLatch(1);//定义了一根门插销

    for (int i = 0; i &lt; 10; i++) {
        Thread thread = new Thread(&quot;worker thread&quot; + i) {
                public void run() {
                    try {
                        startLatch.await();//如果门插销还没减完则等待
                    } catch (InterruptedException e) {

                    }
                    // do xxxx
                }
            };
        thread.start();
    }
    startLatch.countDown();//减少一根门插销
}
</code></pre><h5 id="4-9-2_CycliBarrier-__u7B49_u6240_u6709_u7EBF_u7A0B_u90FD_u8FBE_u5230_u4E00_u4E2A_u8D77_u8DD1_u7EBF_u540E_u624D_u80FD_u5F00_u59CB_u7EE7_u7EED_u8FD0_u884C_u3002"><a href="#4-9-2_CycliBarrier-__u7B49_u6240_u6709_u7EBF_u7A0B_u90FD_u8FBE_u5230_u4E00_u4E2A_u8D77_u8DD1_u7EBF_u540E_u624D_u80FD_u5F00_u59CB_u7EE7_u7EED_u8FD0_u884C_u3002" class="headerlink" title="4.9.2 CycliBarrier. 等所有线程都达到一个起跑线后才能开始继续运行。"></a>4.9.2 CycliBarrier. 等所有线程都达到一个起跑线后才能开始继续运行。</h5><pre><code>public class CycliBarrierTest implements Runnable {
    private CyclicBarrier barrier;

    public CycliBarrierTest(CyclicBarrier barrier) {
        this.barrier = barrier;
    }

    public void run() {
        //do xxxx;
        try {
            this.barrier.await();//线程运行至此会检查是否其它线程都到齐了，没到齐就继续等待。到齐了就执行barrier的run函数体里的内容
        } catch (Exception e) {

        }
    }

    /**
     * @param args
     */
    public static void main(String[] args) {
        //参数2代表两个线程都达到起跑线才开始一起继续往下执行
        CyclicBarrier barrier = new CyclicBarrier(2, new Runnable() {
                public void run() {
                    //do xxxx;
                }
            });
        Thread t1 = new Thread(new CycliBarrierTest(barrier));         
        Thread t2 = new Thread(new CycliBarrierTest(barrier));
        t1.start();
        t2.start();
    }

}
</code></pre><p>这简化了传统的用计数器+wait/notifyAll来实现该功能的方式。</p>
<h3 id="4-10__u5E76_u53D13_u5B9A_u5F8B"><a href="#4-10__u5E76_u53D13_u5B9A_u5F8B" class="headerlink" title="4.10 并发3定律"></a>4.10 并发3定律</h3></li>
<li>Amdahl定律. 给定问题规模，可并行化部分占12%，那么即使把并行运用到极致，系统的性能最多也只能提高1/(1-0.12)=1.136倍。即：并行对提高系统性能有上限。</li>
<li>Gustafson定律. Gustafson定律说Amdahl定律没有考虑随着cpu的增多而有更多的计算能力可被使用。其本质在于更改问题规模从而可以把Amdahl定律中那剩下的88%的串行处理并行化，从而可以突破性能门槛。本质上是一种空间换时间。</li>
<li>Sun-Ni定律. 是前两个定律的进一步推广。其主要思想是计算的速度受限于存储而不是CPU的速度. 所以要充分利用存储空间等计算资源，尽量增大问题规模以产生更好/更精确的解.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/12/14/Java-Thinking-notes/" data-id="cii5wj51u00002ts66jp0un9o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java编程思想/">Java编程思想</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/12/13/android-norm/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android 开发规范</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java编程思想/">Java编程思想</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/Java编程思想/" style="font-size: 10px;">Java编程思想</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/12/14/Java-Thinking-notes/">《Java 编程思想》读书笔记</a>
          </li>
        
          <li>
            <a href="/2015/12/13/android-norm/">Android 开发规范</a>
          </li>
        
          <li>
            <a href="/2015/12/12/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>